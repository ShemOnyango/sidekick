import axios from 'axios';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { CONFIG } from '../../constants/config';
import databaseService from '../database/DatabaseService';

class ApiService {
  constructor() {
    console.log('üîß ApiService initialized with BASE_URL:', CONFIG.API.BASE_URL);
    this.api = axios.create({
      baseURL: CONFIG.API.BASE_URL,
      timeout: CONFIG.API.TIMEOUT,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    });

    this.cachedUser = null;
    this.cacheTimestamp = null;
    this.CACHE_TTL = 5000; // Cache for 5 seconds

    // Request interceptor
    this.api.interceptors.request.use(
      async (config) => {
        // Skip token for auth endpoints and public endpoints
        const publicEndpoints = [
          '/auth/login', 
          '/auth/register', 
          '/auth/forgot-password',
          '/agencies/',  // Public agency data like subdivisions
        ];
        const isPublicEndpoint = publicEndpoints.some(endpoint => config.url?.includes(endpoint));
        
        if (isPublicEndpoint) {
          return config;
        }
        
        // Get token from AsyncStorage
        const now = Date.now();
        if (!this.cachedUser || !this.cacheTimestamp || (now - this.cacheTimestamp) > this.CACHE_TTL) {
          try {
            const userJson = await AsyncStorage.getItem('@HerzogDB:user');
            this.cachedUser = userJson ? JSON.parse(userJson) : null;
            this.cacheTimestamp = now;
          } catch (error) {
            console.error('Error getting user from AsyncStorage:', error);
            this.cachedUser = null;
          }
        }
        
        if (this.cachedUser && this.cachedUser.token) {
          config.headers.Authorization = `Bearer ${this.cachedUser.token}`;
        } else {
          console.warn('No token available for request to:', config.url);
        }
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );

    // Response interceptor
    this.api.interceptors.response.use(
      (response) => response,
      async (error) => {
        const originalRequest = error.config;
        
        // Don't retry refresh-token endpoint to prevent infinite loops
        if (originalRequest.url?.includes('/auth/refresh-token')) {
          // Refresh token failed, log user out
          await this.handleLogout();
          return Promise.reject(error);
        }
        
        // Handle token refresh for other endpoints
        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;
          
          // Check if we have a user before attempting refresh
          try {
            const userJson = await AsyncStorage.getItem('@HerzogDB:user');
            const user = userJson ? JSON.parse(userJson) : null;
            
            if (!user || !user.token) {
              // No user logged in, don't try to refresh
              return Promise.reject(error);
            }
          } catch (err) {
            return Promise.reject(error);
          }
          
          try {
            const newToken = await this.refreshToken();
            if (newToken) {
              originalRequest.headers.Authorization = `Bearer ${newToken}`;
              return this.api(originalRequest);
            } else {
              // Refresh failed, log user out
              await this.handleLogout();
              return Promise.reject(error);
            }
          } catch (refreshError) {
            // Refresh failed, log user out
            await this.handleLogout();
            return Promise.reject(refreshError);
          }
        }
        
        return Promise.reject(error);
      }
    );
  }

  async refreshToken() {
    try {
      const response = await this.api.post('/auth/refresh-token');
      if (response.data.success && response.data.data.token) {
        const user = await databaseService.getUser();
        if (user) {
          await databaseService.updateUserToken(user.user_id, response.data.data.token);
          // Clear cache when token is updated
          this.cachedUser = null;
          this.cacheTimestamp = 0;
        }
        return response.data.data.token;
      }
    } catch (error) {
      console.error('Token refresh failed:', error);
      return null;
    }
  }

  async handleLogout() {
    // Clear cache on logout
    this.cachedUser = null;
    this.cacheTimestamp = 0;
    
    // Clear local storage
    await AsyncStorage.clear();
    await databaseService.clearDatabase();
    
    // Navigate to login (handled by auth service)
    return true;
  }

  // Auth endpoints
  async login(username, password) {
    try {
      console.log('üîê Attempting login to:', this.api.defaults.baseURL + '/auth/login');
      console.log('üåê Full URL:', `${this.api.defaults.baseURL}/auth/login`);
      const response = await this.api.post('/auth/login', { username, password });
      console.log('‚úÖ Login successful');
      return response.data;
    } catch (error) {
      console.log('‚ùå Login failed:', error.message);
      if (error.code === 'ECONNABORTED') {
        console.log('‚è±Ô∏è Request timeout - backend might be unreachable');
      }
      if (error.code === 'ERR_NETWORK' || error.message.includes('Network Error')) {
        console.log('üîå Network error - check WiFi connection and backend status');
      }
      throw this.handleError(error);
    }
  }

  async register(userData) {
    try {
      const response = await this.api.post('/auth/register', userData);
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async getProfile() {
    try {
      const response = await this.api.get('/auth/profile');
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async updateProfile(profileData) {
    try {
      const response = await this.api.put('/auth/profile', profileData);
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async changePassword(currentPassword, newPassword) {
    try {
      const response = await this.api.post('/auth/change-password', {
        currentPassword,
        newPassword
      });
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  // Agency endpoints
  async getAgencies(page = 1, limit = 20, search = '') {
    try {
      const response = await this.api.get('/agencies', {
        params: { page, limit, search }
      });
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async getAgencyStats(agencyId) {
    try {
      const response = await this.api.get(`/agencies/${agencyId}/stats`);
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async getAgencySubdivisions(agencyId) {
    try {
      const response = await this.api.get(`/agencies/${agencyId}/subdivisions`);
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async getSubdivisionTracks(agencyId, subdivisionId) {
    try {
      const response = await this.api.get(`/agencies/${agencyId}/subdivisions/${subdivisionId}/tracks`);
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  // Authority endpoints
  async createAuthority(authorityData) {
    try {
      const response = await this.api.post('/authorities', authorityData);
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async getActiveAuthorities(subdivisionId = null, trackType = null, trackNumber = null) {
    try {
      const response = await this.api.get('/authorities/active', {
        params: { subdivisionId, trackType, trackNumber }
      });
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async getUserAuthorities(activeOnly = true) {
    try {
      const response = await this.api.get('/authorities/my', {
        params: { activeOnly }
      });
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async endAuthority(authorityId, confirmEndTracking = true) {
    try {
      const response = await this.api.post(`/authorities/${authorityId}/end`, {
        confirmEndTracking
      });
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async checkProximity(authorityId, latitude, longitude, maxDistance = 1.0) {
    try {
      const response = await this.api.post(`/authorities/${authorityId}/check-proximity`, {
        latitude,
        longitude,
        maxDistance
      });
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  // Alert endpoints
  async getAlertConfigurations(agencyId) {
    try {
      const response = await this.api.get(`/alerts/config/${agencyId}`);
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async getUserAlerts(limit = 50, unreadOnly = false) {
    try {
      const response = await this.api.get('/alerts/user', {
        params: { limit, unreadOnly }
      });
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async markAlertAsRead(alertId) {
    try {
      const response = await this.api.post(`/alerts/${alertId}/read`);
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  // GPS endpoints
  async updateGPSPosition(gpsData) {
    try {
      const response = await this.api.post('/gps/update', gpsData);
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async getActivePositions() {
    try {
      const response = await this.api.get('/gps/active-positions');
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  // Data download endpoints
  async downloadAgencyData(agencyId) {
    try {
      const response = await this.api.get(`/agencies/${agencyId}/data`);
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async downloadSubdivisionData(agencyId, subdivisionId) {
    try {
      // Backend exposes subdivision downloads under /offline/agency/:agencyId/subdivision/:subdivisionId
      const response = await this.api.get(`/offline/agency/${agencyId}/subdivision/${subdivisionId}`);
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  // Upload endpoints
  async uploadPinPhoto(formData) {
    try {
      const response = await this.api.post('/upload/pin-photo', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async createPin(pinData) {
    try {
      const response = await this.api.post('/pins', pinData);
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async syncData(syncItems) {
    try {
      const response = await this.api.post('/sync', { items: syncItems });
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  // Map layers
  async getMapLayers(params = {}) {
    try {
      const response = await this.api.get('/map/layers', { params });
      return response.data?.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async getMapLayerData(layerId, params = {}) {
    try {
      const response = await this.api.get(`/map/layers/${encodeURI(layerId)}`, { params });
      return response.data?.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  async searchMapLayers(params = {}) {
    try {
      const response = await this.api.get('/map/search', { params });
      return response.data?.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  // Error handling
  handleError(error) {
    if (error.response) {
      // Server responded with error
      const { data, status } = error.response;
      
      if (data && data.error) {
        return {
          message: data.error,
          status,
          details: data.details
        };
      }
      
      return {
        message: `Server error: ${status}`,
        status
      };
    } else if (error.request) {
      // Request made but no response
      return {
        message: 'Network error. Please check your connection.',
        status: 0
      };
    } else {
      // Something else happened
      return {
        message: error.message || 'An unknown error occurred',
        status: -1
      };
    }
  }

  // Network status
  isNetworkError(error) {
    return error.status === 0;
  }
}

// Export singleton instance
const apiService = new ApiService();
export default apiService;
